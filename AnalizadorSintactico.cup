
import java_cup.runtime.*;
import java.io.*;
import javax.swing.JFileChooser;
import java.util.*;
import java.util.Scanner;

parser code
{:

	int err_sintactico = 0;
	int err_semantico = 0;
	
	
	boolean isRead = false;
	boolean isRnd = false;
	boolean isData = false;
	
	static HashMap<String, Object> tablaSimbolos = new HashMap<String, Object> ();
	ArrayList<String> listaTokens = new ArrayList<String>();

	public static void main (String argsv[]) throws Exception {
		
		BufferedReader nombreArchivo = new BufferedReader(new InputStreamReader(System.in));
        String entrada = nombreArchivo.readLine();
        //String entrada = "Prueba1.bas";
        String tipoCorrecto = "bas";
		String tipoArchivo = entrada.substring(entrada.lastIndexOf(".")+1);
        if(!tipoArchivo.equals(tipoCorrecto)){
    		System.err.println("Extension del archivo necesaria '.bas'\n");
    	} else {
	        FileInputStream fileInput = new FileInputStream(entrada);
	  		AnalizadorSintacticoCup parser;
	  		AnalizadorLexico lexico = new AnalizadorLexico(fileInput);
	  		parser = new AnalizadorSintacticoCup(lexico);
	    	parser.parse();
	    	
	    	if(parser.err_sintactico == 0 && parser.err_semantico == 0) {
	    		System.out.println("Analisis realizado correctamente");
	    		System.out.println("Lista de Tokens identificados");
	    		parser.printToken();
	    		parser.print();
	    	} else { 
	    		System.out.println("Hay errores en el codigo");
	    		System.out.println("Errores sintacticos: " + parser.err_sintactico);
	    		System.out.println("Errores semanticos: " + parser.err_semantico);
	    		System.out.println("Lista de Tokens identificados");
	    		parser.printToken();
	    		parser.print();
	    	}
    	}

   	}

   	public void syntax_error(Symbol s) {
  		System.out.println("Error sintactico en linea "+(s.left)+" y columna "+(s.right+1)+ ": token leido \""+s.value+"\", se esperaba otro token.\n");
  		err_sintactico++;
	}

	public HashMap getTablaSimbolos(){
  		return tablaSimbolos;
  	}

  	public void print() {
  		System.out.println("");
  		System.out.println("   ::: TABLA DE SIMBOLOS :::    ");	
	  	System.out.println("--------------------------------");
	  	System.out.println("Tama√±o de la tabla de simbolos: " + tablaSimbolos.size());
		Iterator itert = tablaSimbolos.entrySet().iterator();
		while (itert.hasNext()) {
	    	Map.Entry entry = (Map.Entry)itert.next();
	    	System.out.println(entry.getKey()); 
		}
	  	System.out.println("--------------------------------");	
  	}

	public ArrayList getListaToken() {
		return listaTokens;
	}
	
	public void printToken() {
		int i = 0;
		while(i < getListaToken().size()) {
			if (i%6 == 0) {
				System.out.println("");
			}
			System.out.print(getListaToken().get(i) + "\t");
			i++;
		}
		System.out.println("");
	}

	public void declarar(Object dat) {
		if(!getTablaSimbolos().containsKey(dat)){
			String tipo = "cadena";
			Ident id = new Ident(dat.toString(), tipo);
			getTablaSimbolos().put(id.getNombre(), id);
		}
	}
	
	public void check(Object dat) {
		if(!getTablaSimbolos().containsKey(dat)){
				System.out.println("Variable " + dat.toString() + " no declarada");
				err_semantico++;
			}
	}

	/*public boolean comprobarTipo(Symbol s1, Symbol s2) {

	}*/

:}

action code
{:
	
:}

terminal		TK_DATA, TK_DEF, TK_DIM, TK_END, TK_FOR, TK_GO, TK_GOSUB, TK_GOTO, TK_IF;
terminal		TK_INPUT, TK_LET, TK_NEXT, TK_ON, TK_PRINT, TK_RANDOMIZE, TK_READ, TK_REM, TK_RESTORE;
terminal		TK_RETURN, TK_STEP, TK_STOP, TK_THEN, TK_TO, TK_ABS, TK_ATN, TK_COS, TK_EXP, TK_INT;
terminal		TK_LOG, TK_RND, TK_SGN, TK_SIN, TK_SQR, TK_TAN, TK_ID, TK_INT_SIM, TK_INT_SUS, TK_FN; 
terminal		TK_PAR_IZQ, TK_PAR_DER;
terminal		TK_IGUAL, TK_MENOR, TK_MAYOR, TK_MENOR_IGUAL, TK_MAYOR_IGUAL, TK_DISTINTO;
terminal		TK_PUNTOCOMA, TK_COMA;
terminal		TK_SUMA, TK_RESTA, TK_MUL, TK_DIV, TK_EL;
terminal		TK_DIG, TK_CADENA;

non terminal	abs, atn, cos, exp, int, log, rnd, sgn, sin, sqr, tan;
non terminal 	let, for, condicional, print, input, data, c_data, read, dim, def, gosub, randomize, c_read, restore;
non terminal	comparacion, operador;
non terminal	dato, expresion, next, goto;
non terminal	programa, bloque, funcion, linea, fin;

programa::= bloque fin;

bloque::= linea | bloque linea;

linea::= TK_DIG:token funcion {:
			parser.getListaToken().add(token.toString());
		:} | error;

fin::= TK_DIG:token TK_END:token2 {:
			parser.getListaToken().add(token.toString());
			parser.getListaToken().add(token2.toString());
		:} | TK_DIG:token TK_STOP:token2 {:
			parser.getListaToken().add(token.toString());
			parser.getListaToken().add(token2.toString());
		:};

funcion::= abs | tan | sqr | sin | sgn | rnd | log | int | exp | cos | atn | for | condicional | let | 
		   print | input | goto | data | read | dim | def | gosub | randomize | restore;

//Comienzo de estructuras de control
condicional::= TK_IF dato comparacion TK_CADENA TK_THEN dato {:

				:}| TK_IF dato comparacion TK_CADENA TK_THEN goto {:
				:} | TK_IF dato comparacion dato TK_THEN dato {:
				:} | TK_IF dato comparacion dato TK_THEN goto {:
				:} | TK_IF dato comparacion expresion TK_THEN dato {:
				:} | TK_IF dato comparacion expresion TK_THEN goto {:
				:};

//Funcion For
for::= TK_FOR:token TK_INT_SIM:token2 TK_IGUAL:token3 TK_DIG:token4 TK_TO:token5 TK_INT_SIM:token6 bloque next {:
			parser.declarar(token2);
			parser.declarar(token6);
			parser.getListaToken().add(token.toString());
			parser.getListaToken().add(token2.toString());
			parser.getListaToken().add(token3.toString());
			parser.getListaToken().add(token4.toString());
			parser.getListaToken().add(token5.toString());
			parser.getListaToken().add(token6.toString());
			
		:} | TK_FOR:token TK_INT_SIM:token2 TK_IGUAL:token3 TK_DIG:token4 TK_TO:token5 TK_DIG:token6 bloque next {:
			parser.declarar(token2);
			parser.getListaToken().add(token.toString());
			parser.getListaToken().add(token2.toString());
			parser.getListaToken().add(token3.toString());
			parser.getListaToken().add(token4.toString());
			parser.getListaToken().add(token5.toString());
			parser.getListaToken().add(token6.toString());
			
		:} | TK_FOR:token TK_INT_SIM:token2 TK_IGUAL:token3 TK_DIG:token4 TK_TO:token5 TK_INT_SIM:token6 TK_STEP:token7 TK_DIG:token8 bloque next {:
			parser.declarar(token2);
			parser.declarar(token6);
			parser.getListaToken().add(token.toString());
			parser.getListaToken().add(token2.toString());
			parser.getListaToken().add(token3.toString());
			parser.getListaToken().add(token4.toString());
			parser.getListaToken().add(token5.toString());
			parser.getListaToken().add(token6.toString());
			parser.getListaToken().add(token7.toString());
			parser.getListaToken().add(token8.toString());
			
		:} | TK_FOR:token TK_INT_SIM:token2 TK_IGUAL:token3 TK_DIG:token4 TK_TO:token5 TK_DIG:token6 TK_STEP:token7 TK_DIG:token8 bloque next {:
			parser.declarar(token2);
			parser.getListaToken().add(token.toString());
			parser.getListaToken().add(token2.toString());
			parser.getListaToken().add(token3.toString());
			parser.getListaToken().add(token4.toString());
			parser.getListaToken().add(token5.toString());
			parser.getListaToken().add(token6.toString());
			parser.getListaToken().add(token7.toString());
			parser.getListaToken().add(token8.toString());
		:};

next::= TK_DIG:token TK_NEXT:token2 TK_INT_SIM:token3 {:
		parser.declarar(token3);
		parser.getListaToken().add(token.toString());
		parser.getListaToken().add(token2.toString());
		parser.getListaToken().add(token3.toString());
	:};

//Funcion let
let::= TK_LET:token TK_ID:dat TK_IGUAL:token2 expresion {:
				parser.declarar(dat);
				parser.getListaToken().add(token.toString());
				parser.getListaToken().add(token2.toString());
		:} | TK_LET:token TK_INT_SIM:dat TK_IGUAL:token2 TK_CADENA:token3 {:
				parser.declarar(dat);
				parser.getListaToken().add(token.toString());
				parser.getListaToken().add(token2.toString());
				parser.getListaToken().add("Cadena");
		:} | TK_LET:token TK_INT_SUS:dat TK_IGUAL:token2 TK_CADENA:token3 {:
				parser.declarar(dat);
				parser.getListaToken().add(token.toString());
				parser.getListaToken().add(token2.toString());
				parser.getListaToken().add("Cadena");
		:};
		
//Funcion read
read::= TK_READ:token c_data {:
			parser.getListaToken().add(token.toString());
			if (!parser.isData) {
				System.out.println("Se necesita una declaracion previa de DATA");
				parser.err_semantico++;
			}
			parser.isRead = true;
		:};

restore::= TK_RESTORE:token {:
			parser.getListaToken().add(token.toString());
			if (!parser.isRead) {
				System.out.println("No se ha encontrado la instruccion READ");
				parser.err_semantico++;
			}
		:};

c_read::= dato | dato TK_COMA:token c_read {:
		  	parser.getListaToken().add(token.toString());
		  :};
	
//Funcion Data
data::= TK_DATA:token c_data {:
			parser.getListaToken().add(token.toString());
			parser.isData = true;
		:};

c_data::= TK_ID:dat {:
			parser.getListaToken().add(dat.toString());
			parser.declarar(dat);
			
		:} | TK_INT_SIM:dat {:
			parser.getListaToken().add(dat.toString());
			parser.declarar(dat);
			
		:} | TK_INT_SUS:dat {:
			parser.getListaToken().add(dat.toString());
			parser.declarar(dat);
			
		:} | TK_ID:dat TK_COMA:token c_data {:
			parser.getListaToken().add(token.toString());
			parser.getListaToken().add(dat.toString());
			parser.declarar(dat);
			
		:} | TK_INT_SIM:dat TK_COMA:token c_data {:
			parser.getListaToken().add(token.toString());
			parser.getListaToken().add(dat.toString());
			parser.declarar(dat);
			
		:} | TK_INT_SUS:dat TK_COMA:token c_data {:
			parser.getListaToken().add(token.toString());
			parser.getListaToken().add(dat.toString());
			parser.declarar(dat);
			
		:};
		  

//Funcion Print
print::= TK_PRINT TK_CADENA TK_PUNTOCOMA TK_ID |
		TK_PRINT TK_CADENA TK_PUNTOCOMA |
		TK_PRINT dato;

//Funcion Input		
input::= TK_INPUT TK_CADENA TK_PUNTOCOMA TK_ID |
		TK_INPUT TK_CADENA TK_PUNTOCOMA;

//Funcion Dim
dim::= TK_DIM TK_INT_SUS;

//Auxiliar para declarar dimensiones

//Funcion goto		
goto::= TK_GOTO TK_DIG;

//Funcion Def
def::= TK_DEF TK_FN TK_INT_SIM TK_IGUAL dato |
	   TK_DEF TK_FN TK_INT_SIM TK_PAR_IZQ dato TK_PAR_DER TK_IGUAL expresion;
	   
//Funcion Gosub
gosub::= TK_GOSUB dato bloque TK_RETURN;

//Funcion randomize
randomize::= TK_RANDOMIZE {:
			if(!parser.isRnd) {
				System.out.println("No se ha encontrado la instruccion RND");
				System.out.println("Para usar esta funcion se necesita una invocacion previa de la funcion RND");
				parser.err_semantico++;
			} 
		:};

expresion::= dato operador dato | expresion operador dato |
			dato operador TK_CADENA;


//Funciones predefinidas
abs::= TK_ABS TK_PAR_IZQ dato TK_PAR_DER;

tan::= TK_TAN TK_PAR_IZQ dato TK_PAR_DER;

sqr::= TK_SQR TK_PAR_IZQ dato TK_PAR_DER;

sin::= TK_SIN TK_PAR_IZQ dato TK_PAR_DER;

sgn::= TK_SGN TK_PAR_IZQ dato TK_PAR_DER;

rnd::= TK_RND TK_PAR_IZQ dato TK_PAR_DER {:
			parser.isRnd = true;
	   :};

log::= TK_LOG TK_PAR_IZQ dato:dat TK_PAR_DER;

int::= TK_INT TK_PAR_IZQ dato TK_PAR_DER;

exp::= TK_EXP TK_PAR_IZQ dato TK_PAR_DER;

cos::= TK_COS TK_PAR_IZQ dato TK_PAR_DER;

atn::= TK_ATN TK_PAR_IZQ dato TK_PAR_DER;


//Operadores
comparacion::= TK_MENOR | TK_MAYOR | TK_MAYOR_IGUAL

				| TK_MENOR_IGUAL | TK_DISTINTO | TK_IGUAL;

				
operador::= TK_SUMA | TK_RESTA | TK_MUL | TK_DIV | TK_EL;

//Unidad minima de informacion, el dato y la constante.
dato::= TK_ID:dat {:
			parser.getListaToken().add(dat.toString());
			parser.check(dat);
			
		:} | TK_INT_SIM:dat {:
			parser.getListaToken().add(dat.toString());
			parser.check(dat);
			
		:} | TK_INT_SUS:dat {:
			parser.getListaToken().add(dat.toString());
			parser.check(dat);
			
		:} | TK_DIG:dat {:
			parser.getListaToken().add(dat.toString());
		:};
